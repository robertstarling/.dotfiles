# Useful overrides for API testing suites
# - Re-using resource group names and skipping cleanup speeds up iterative testing
# - The $$ variable in the ResourceGroup name ensures uniqueness per shell process
declare -x ResourceGroup="robstarling-tmp-api-testing-$(date +%y%m-%d)-$$"
declare -x SkipCleanupSuite=True
declare -x RunInParallel=true
declare -x RunInParallelArg="--procs=4"

# Lookup the Azure resource ID of the first cluster containing the specific substring
# Return an error if no matching cluster is found
get_cluster_id() {
  az resource list --resource-type "Microsoft.NetworkCloud/clusters" --query "[?contains(name, '$1')].id" -o tsv
}

# with error handling
get_cluster_id_or_fail() {
  local substring="$1"
  local cluster_id
  cluster_id=$(az resource list --resource-type "Microsoft.NetworkCloud/clusters" --query "[?contains(name, '$substring')].id" -o tsv | head -n 1)
  if [ -z "$cluster_id" ]; then
    echo "No cluster found containing substring: $substring" >&2
    return 1
  fi
  echo "$cluster_id"
}

# sim_health runs the cluster-health suite against the first matching cluster.
# Accepts either a descriptive substring or a numeric build id (simdev-<id>).
# Environment variables are set only for the child process and won't leak
# into the caller's shell after the function returns.
sim_health() {
  local substring="$1"
  if [ -z "$substring" ]; then
    echo "Usage: sim_health <cluster-name-substring|build-id>" >&2
    return 2
  fi

  if [[ "$substring" =~ ^[0-9]+$ ]]; then
    substring="simdev-$substring"
  fi

  source ~/e2e/sim || return 1

  # Resolve cluster id (first match) and fail if not found.
  local ClusterID
  ClusterID=$(get_cluster_id_or_fail "$substring") || return 1

  # local run_command='ClusterID="$ClusterID" Suites="cluster-health" ./scripts/run-suites.sh --label-filter "!AzureLocalRackScale"'
  local run_command='ClusterID="$ClusterID" Suites="cluster-health" ./scripts/run-suites.sh'

  cat <<ENVINFO
Running cluster-health with:
  ResourceGroup=${ResourceGroup:-<unset>}
  SkipCleanupSuite=${SkipCleanupSuite:-<unset>}
  SkipDisruptiveTests=${SkipDisruptiveTests:-<unset>}
  ApiVersion=${ApiVersion:-<unset>}
  ClusterID=${ClusterID:-<unset>}
  IncludeLabels=${IncludeLabels:-<unset>}
  RunInParallel=${RunInParallel:-<unset>}

Command:
  ( cd ~/nc-api-testing/ && $run_command )

ENVINFO

  printf 'Continue? [Y]: '
  local confirm=""
  if ! read -r confirm; then
    echo
    return 0
  fi
  [ -z "$confirm" ] && confirm="y"
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo "cluster-health run skipped."
    return 0
  fi

  # Ephemeral values (30-char date pattern kept as original intent).
  # local ResourceGroup="robstarling-tmp-api-testing-$$-$(date +%y%m-%d)"
  # local RunInParallel=true
  # local SkipCleanupSuite=True
  # local Suites="cluster-health"
  # local Processors=4
  # These labels differentiate between deployment types:
  # AzureLocalRackScale or AzureOperatorNexus
  # local LabelFilter='!AzureLocalRackScale' 

  ( cd ~/git2/nc-api-testing/ || exit 1
    eval "$run_command"
    # Inline env assignment ensures variables apply only to this command.
    # ClusterID="$ClusterID" \
    # ResourceGroup="$ResourceGroup" \
    # RunInParallel="$RunInParallel" \
    # SkipCleanupSuite="$SkipCleanupSuite" \
    # Processors="$Processors" \
    # LabelFilter="$LabelFilter" \
    #   ./scripts/run-suites.sh --label-filter "$LabelFilter" # --procs="$Processors" 
  )
}
