# Azure subscriptions
alias .sandbox='az account set -s a3eeb848-665a-4dbf-80a4-eb460930fb23'
alias .dev='az account set -s fca2e8ee-1179-48b8-9532-428ed0873a2e'

# Login helper ensuring desired tenant + subscription selected
azure_login() {
  local target_tenant="72f988bf-86f1-41af-91ab-2d7cd011db47"
  local target_subscription="a3eeb848-665a-4dbf-80a4-eb460930fb23"
  local force="false"
  local verbose="false"

  # Flags: --force forces re-login; --verbose prints diagnostics
  while [ $# -gt 0 ]; do
    case "$1" in
      --force) force="true" ; shift ;;
      --verbose|-v) verbose="true" ; shift ;;
      *) break ;;
    esac
  done

  # Environment override: AZURE_LOGIN_FORCE=1 forces re-login
  if [ "${AZURE_LOGIN_FORCE:-}" = "1" ]; then
    force="true"
  fi

  # Helper to log when verbose
  _azl_log() { [ "$verbose" = "true" ] && echo "[azure_login] $*" || true; }

  # Determine current subscription (may be present even if token expired)
  local current_sub="" current_tenant=""
  if current_sub=$(az account show --query id -o tsv 2>/dev/null); then
    current_tenant=$(az account show --query tenantId -o tsv 2>/dev/null || true)
    _azl_log "Detected current subscription: $current_sub (tenant: $current_tenant)"
  fi

  # Function to test whether tokens are currently usable. We request an access token; this will fail fast if refresh token expired.
  _token_valid() {
    az account get-access-token --resource https://management.azure.com/ --query accessToken -o tsv >/dev/null 2>&1
  }

  # Fast path: subscription matches AND token retrieval works AND not forced.
  if [ "$force" = "false" ] && [ "$current_sub" = "$target_subscription" ]; then
    if _token_valid; then
      _azl_log "Fast path: valid token & correct subscription; no re-login needed.";
      return 0
    else
      _azl_log "Token invalid/expired; re-authentication required."
    fi
  fi

  # Prefer service principal creds if present (non-interactive)
  if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ]; then
    local login_tenant="${AZURE_TENANT_ID:-$target_tenant}"
    echo "Logging into Azure with service principal for tenant $login_tenant ..."
    if ! az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$login_tenant" --only-show-errors >/dev/null; then
      echo "Failed SP login" >&2
      return 1
    fi
  else
    echo "Interactive Azure login for tenant $target_tenant ..."
    if ! az login --tenant "$target_tenant" --only-show-errors >/dev/null; then
      echo "Interactive login failed" >&2
      return 1
    fi
  fi

  # Select subscription explicitly
  if ! az account set -s "$target_subscription" 2>/dev/null; then
    echo "Failed to set subscription $target_subscription" >&2
    return 1
  fi

  # Optional: reduce noisy warnings for subsequent commands
  az config set core.only_show_errors=true >/dev/null 2>&1 || true

  if _token_valid; then
    _azl_log "Verified new token acquisition succeeded."
  else
    _azl_log "Warning: token validation failed immediately after login (this is unexpected)."
  fi

  echo "Azure CLI context set to subscription: $target_subscription (tenant: $target_tenant)"
}

# Search for Azure Resource Groups by chaining contains filters.
getrg() {
  local query="[]"
  for arg in "$@"; do
    query="[?contains(name, '$arg')] | $query"
  done
  query="${query% | []}"
  az group list --query "$query.{Name:name, Location:location}" --output table
}

# Check for resource groups matching 'robstarling*<optionalpattern>*-simdev-[0-9]*' and provide the user with an
# interactive menu of matching resource group names, allowing them to select one for follow-up actions.
# Interactive actions (prompted at runtime):
#   1) ssh into the simulator via sim_ssh
#   2) run sim_health for the selected simulator
# Flags:
#   --help            display usage information
# When multiple matches exist, results are shown newest-first but the default selection targets the oldest build.
sim() {
  local action=""
  local optionalFilter=""
  local usage_msg="Usage: sim [--help] [filter]\n\n  --help    display this message\n  filter    optional substring to narrow RG names\n\nYou will be prompted to choose an action before selecting a simulator:\n  1) SSH into the selected simulator\n  2) Run sim_health for the selected simulator"

  while [ $# -gt 0 ]; do
    case "$1" in
      --help|-h)
        echo -e "$usage_msg"
        return 0
        ;;
      --*)
        echo "Unknown option: $1" >&2
        echo -e "$usage_msg" >&2
        return 1
        ;;
      *)
        if [ -n "$optionalFilter" ]; then
          echo "Only one filter argument is supported" >&2
          echo -e "$usage_msg" >&2
          return 1
        fi
        optionalFilter="$1"
        shift
        ;;
    esac
  done

  local rg_list
  if ! rg_list=$(az group list --query "[?contains(name, 'robstarling') && contains(name, 'simdev')].name" --output tsv 2>/dev/null); then
    echo "Failed to retrieve Azure resource groups" >&2
    return 1
  fi

  local filter_lower=${optionalFilter,,}
  local candidates=()
  while IFS= read -r rg; do
    [ -z "$rg" ] && continue
    [[ $rg != robstarling* ]] && continue
    [[ $rg =~ -simdev-[0-9]+$ ]] || continue
    if [ -n "$filter_lower" ]; then
      local rg_lower=${rg,,}
      [[ $rg_lower == *"$filter_lower"* ]] || continue
    fi
    candidates+=("$rg")
  done <<<"$rg_list"

  local count=${#candidates[@]}
  if [ "$count" -eq 0 ]; then
    if [ -n "$optionalFilter" ]; then
      echo "No simulator resource groups found matching filter '$optionalFilter'" >&2
    else
      echo "No simulator resource groups found" >&2
    fi
    return 1
  fi

  while [ -z "$action" ]; do
    echo "Select simulator action:"
    echo "  1) SSH into simulator"
    echo "  2) Run cluster-health API tests"
    local action_reply=""
    printf 'Choice [1]: '
    if ! read -r action_reply; then
      echo
      action="ssh"
      break
    fi
    case "$action_reply" in
      ""|"1")
        action="ssh"
        ;;
      "2")
        action="health"
        ;;
      *)
        echo "Invalid selection. Enter 1 or 2." >&2
        ;;
    esac
  done

  local selected_rg=""
  if [ "$count" -eq 1 ]; then
    selected_rg="${candidates[0]}"
  else
    local sorted_output
    sorted_output=$(printf '%s\n' "${candidates[@]}" | awk '{
        build=0
        if (match($0, /simdev-([0-9]+)/, m)) { build=m[1] }
        printf "%010d\t%s\n", build, $0
      }' | sort -k1,1nr | cut -f2-)

    mapfile -t candidates <<<"$sorted_output"
    local last_index=$(( ${#candidates[@]} - 1 ))
    local default_rg="${candidates[$last_index]}"
    local default_position=$((last_index + 1))
    local selection=""

    if command -v fzf >/dev/null 2>&1; then
      local fzf_opts=(
        --prompt "Select simulator RG > "
        --header "Enter accepts default (#${default_position})"
        --height=40%
        --reverse
      )
      selection=$(printf '%s\n' "${candidates[@]}" | fzf "${fzf_opts[@]}")
      if [ -z "$selection" ]; then
        echo "No selection made; defaulting to $default_rg"
        selection="$default_rg"
      fi
    else
      echo "Multiple simulator resource groups found (default: oldest):"
      local idx=1
      for rg in "${candidates[@]}"; do
        printf '  %d) %s\n' "$idx" "$rg"
        idx=$((idx + 1))
      done
      printf 'Select target (default %d): ' "$default_position"
      local reply
      read -r reply
      if [ -z "$reply" ]; then
        selection="$default_rg"
      elif [[ "$reply" =~ ^[0-9]+$ ]] && [ "$reply" -ge 1 ] && [ "$reply" -le "${#candidates[@]}" ]; then
        local reply_index=$((reply - 1))
        selection="${candidates[$reply_index]}"
      else
        echo "Invalid selection" >&2
        return 1
      fi
    fi

    selected_rg="$selection"
  fi

  local build_id
  build_id=$(echo "$selected_rg" | grep -oE '[0-9]+$')
  if [ -z "$build_id" ]; then
    echo "Unable to parse simdev build id from $selected_rg" >&2
    return 1
  fi

  case "$action" in
    ssh)
      sim_ssh "$build_id"
      ;;
    health)
      if ! type sim_health >/dev/null 2>&1; then
        echo "sim_health function is not available in this shell" >&2
        return 1
      fi
      sim_health "$build_id"
      ;;
    *)
      echo "Unhandled action: $action" >&2
      return 1
      ;;
  esac
}

# ssh to a simulator using only the build number, e.g.
#   sim_ssh 3391322
sim_ssh() {
  local build_id=$1
  local sandboxSubscription=a3eeb848-665a-4dbf-80a4-eb460930fb23

  if [[ -z "$build_id" || ! "$build_id" =~ ^[0-9]+$ ]]; then
    echo "Usage: sim_ssh <build-id>" >&2
    return 1
  fi

  local rg_candidates target_rg=""
  if ! rg_candidates=$(az group list --query "[?contains(name, 'simdev-${build_id}')].name" --output tsv 2>/dev/null); then
    echo "Failed to retrieve simulator resource groups" >&2
    return 1
  fi

  while IFS= read -r rg; do
    [ -z "$rg" ] && continue
    [[ $rg == *"-simdev-${build_id}"* ]] || continue
    target_rg="$rg"
    break
  done <<<"$rg_candidates"

  if [ -z "$target_rg" ]; then
    echo "Unable to locate simulator resource group for build ${build_id}" >&2
    return 1
  fi

  az ssh arc -g "$target_rg" -n "simdev-${build_id}-vm-1" --subscription $sandboxSubscription
}

# Function to retrieve and assign BMM Replace values to environment variables
get_baremetal_info() {
  local RG=$1
  local MACHINE_NAME=$2

  # Retrieve the values and assign them to environment variables
  local machine_info=$(az networkcloud baremetalmachine show -n $MACHINE_NAME -g $RG --query "{machineName:machineName, bootMacAddress:bootMacAddress, bmcMacAddress:bmcMacAddress, serialNumber:serialNumber}" --output tsv)

  # Split the output into individual variables
  read machineName bootMacAddress bmcMacAddress serialNumber <<< "$machine_info"

  # Export the variables to make them available in the current shell session
  export machineName
  export bootMacAddress
  export bmcMacAddress
  export serialNumber

  # Print the values to verify
  echo "\$machineName: $machineName"
  echo "\$bootMacAddress: $bootMacAddress"
  echo "\$bmcMacAddress: $bmcMacAddress"
  echo "\$serialNumber: $serialNumber"

  # BMC password is also needed
  echo
  echo "To retrieve BMC password:"
  echo "kubectl -n nc-system get secret $machineName-bmc -o json | jq -r .data.password | base64 -d"
}

# janitor checks an Azure resource group's "Created" tag,
# which is used by the Janitor to determine when to clean up the resource group.
#
# Usage:
#   azure_rg_reset_created_tag RESOURCE_GROUP [SUBSCRIPTION]
janitor() {
  local __resource_group="$1"
  local __subscription="$2"

  # Specify subscription only if provided in the parameters. Otherwise az will use the current one.
  local subscription_args=()
  if [ -n "${__subscription:-}" ]; then
    subscription_args=(--subscription "$__subscription")
  fi

  # Read existing tags as JSON (null if none)
  local tags_json
  if ! tags_json=$(az group show "${subscription_args[@]}" --name "$__resource_group" --query tags -o json 2>/dev/null); then
    echo "Failed to retrieve tags for resource group: $__resource_group" >&2
    return 1
  fi

  echo "$tags_json"

  # Parse the Created tag if present, and display the number of days remaining until stale
  local created=""
  if command -v jq >/dev/null 2>&1; then
    created=$(echo "$tags_json" | jq -r '.Created // empty')
  else
    created=$(echo "$tags_json" | grep -o '"Created"[^"]*"[^"]*"' | sed -E 's/.*"Created" *: *"([^"]*)".*/\1/')
  fi

  if [ -n "$created" ]; then
    if command -v days_until_stale >/dev/null 2>&1; then
      local remaining
      remaining=$(days_until_stale "$created" 30 2>/dev/null || true)
      [ -n "$remaining" ] && echo "$remaining remaining"
    else
      echo "Created: $created"
    fi
  fi  
}

# azure_rg_reset_created_tag updates an Azure resource group's "Created" tag,
# which is used by the Janitor to determine when to clean up the resource group.
#
# Usage:
#   azure_rg_reset_created_tag RESOURCE_GROUP SUBSCRIPTION
janitor_reset() {
  local __resource_group="$1"
  local __subscription="$2"
  local __ts=$(date +%Y-%m-%dT%H:%M:%SZ)

  # Specify subscription only if provided in the parameters. Otherwise az will use the current one.
  local subscription_args=()
  if [ -n "${__subscription:-}" ]; then
    subscription_args=(--subscription "$__subscription")
  fi

  # Read existing tags as JSON (null if none), then merge/overwrite the Created/CleanupFrequency/Owner keys.
  local existing_tags_json
  existing_tags_json=$(az group show "${subscription_args[@]}" --name "$__resource_group" --query tags -o json 2>/dev/null || echo null)

  local new_tags_json
  new_tags_json=$(echo "$existing_tags_json" | jq --arg ts "$__ts" '. // {} | .Created=$ts')

  # Convert merged tags JSON into key=value pairs for the --tags arg.
  local tags_kv
  IFS=$'\n' read -r -d '' -a tags_kv < <(echo "$new_tags_json" | jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' && printf '\0')

  az group update "${subscription_args[@]}" --name "$__resource_group" --tags "${tags_kv[@]}" --only-show-errors >/dev/null
}
