# Azure subscriptions
alias .sandbox='az account set -s a3eeb848-665a-4dbf-80a4-eb460930fb23'
alias .dev='az account set -s fca2e8ee-1179-48b8-9532-428ed0873a2e'

# Login helper ensuring desired tenant + subscription selected
azure_login() {
  local target_tenant="72f988bf-86f1-41af-91ab-2d7cd011db47"
  local target_subscription="a3eeb848-665a-4dbf-80a4-eb460930fb23"
  local force="false"

  # Allow optional flag: azure_login --force
  if [ "$1" = "--force" ]; then
    force="true"
  fi

  # Fast path: already logged into correct subscription (unless --force)
  if [ "$force" = "false" ]; then
    if current_sub=$(az account show --query id -o tsv 2>/dev/null); then
      if [ "$current_sub" = "$target_subscription" ]; then
        return 0
      fi
    fi
  fi

  # Prefer service principal creds if present (non-interactive)
  if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ]; then
    # Respect provided AZURE_TENANT_ID, else fall back to target_tenant
    local login_tenant="${AZURE_TENANT_ID:-$target_tenant}"
    echo "Logging into Azure with service principal for tenant $login_tenant ..."
    if ! az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$login_tenant" --only-show-errors >/dev/null; then
      echo "Failed SP login" >&2
      return 1
    fi
  else
    # Interactive login scoped to tenant to avoid enumerating other tenants
    echo "Interactive Azure login for tenant $target_tenant ..."
    if ! az login --tenant "$target_tenant" --only-show-errors >/dev/null; then
      echo "Interactive login failed" >&2
      return 1
    fi
  fi

  # Select subscription explicitly (suppress output)
  if ! az account set -s "$target_subscription" 2>/dev/null; then
    echo "Failed to set subscription $target_subscription" >&2
    return 1
  fi

  # Optional: reduce noisy warnings for subsequent commands
  az config set core.only_show_errors=true >/dev/null 2>&1 || true

  echo "Azure CLI context set to subscription: $target_subscription (tenant: $target_tenant)"
}

# Search for Azure Resource Groups
getrg() {
  local query="[]"
  for arg in "$@"; do
    query="[?contains(name, '$arg')] | $query"
  done
  query="${query% | []}"
  az group list --query "$query.{Name:name, Location:location}" --output table
}

# Search for Simulator hosted resource groups
function getsim() {
    local first_pattern="$1"
    local second_pattern_prefix="$2"

    # Get resource groups matching the first pattern
    local resource_groups=$(az group list --query "[?contains(name, 'robstarling') && contains(name, 'simdev')].name" --output tsv)
    echo $resource_groups

    for rg in $resource_groups; do
      # Extract the unique identifier from the first pattern
      local unique_id=$(echo $rg | grep -oP '(?<=simdev-)\d+')
      echo $unique_id

      # Construct the second pattern
      local second_pattern="simdev-${unique_id}-cluster-1-HostedResources-"
      echo $second_pattern

      # Get resource groups matching the second pattern
      az group list --query "[?contains(name, '$second_pattern')].{Name:name, Location:location}" --output table
    done
}

# ssh to simulator using the Resource Group name, e.g. 
#   getrg sim robstarling
#   sim robstarling-2504-12_id-simdev-3391322
sim() {
  local rg=$1
  local id=$(echo "$rg" | grep -oE '[0-9]+$')
  local sandboxSubscription=a3eeb848-665a-4dbf-80a4-eb460930fb23
  az ssh arc -g "$rg" -n "simdev-${id}-vm-1" --subscription $sandboxSubscription
}

# Function to retrieve and assign BMM Replace values to environment variables
get_baremetal_info() {
  local RG=$1
  local MACHINE_NAME=$2

  # Retrieve the values and assign them to environment variables
  local machine_info=$(az networkcloud baremetalmachine show -n $MACHINE_NAME -g $RG --query "{machineName:machineName, bootMacAddress:bootMacAddress, bmcMacAddress:bmcMacAddress, serialNumber:serialNumber}" --output tsv)

  # Split the output into individual variables
  read machineName bootMacAddress bmcMacAddress serialNumber <<< "$machine_info"

  # Export the variables to make them available in the current shell session
  export machineName
  export bootMacAddress
  export bmcMacAddress
  export serialNumber

  # Print the values to verify
  echo "\$machineName: $machineName"
  echo "\$bootMacAddress: $bootMacAddress"
  echo "\$bmcMacAddress: $bmcMacAddress"
  echo "\$serialNumber: $serialNumber"

  # BMC password is also needed
  echo
  echo "To retrieve BMC password:"
  echo "kubectl -n nc-system get secret $machineName-bmc -o json | jq -r .data.password | base64 -d"
}

# janitor checks an Azure resource group's "Created" tag,
# which is used by the Janitor to determine when to clean up the resource group.
#
# Usage:
#   azure_rg_reset_created_tag RESOURCE_GROUP [SUBSCRIPTION]
janitor() {
  local __resource_group="$1"
  local __subscription="$2"

  # Specify subscription only if provided in the parameters. Otherwise az will use the current one.
  local subscription_args=()
  if [ -n "${__subscription:-}" ]; then
    subscription_args=(--subscription "$__subscription")
  fi

  az group show  "${subscription_args[@]}" --name $__resource_group --query tags -o json
}

# azure_rg_reset_created_tag updates an Azure resource group's "Created" tag,
# which is used by the Janitor to determine when to clean up the resource group.
#
# Usage:
#   azure_rg_reset_created_tag RESOURCE_GROUP SUBSCRIPTION
janitor_reset() {
  local __resource_group="$1"
  local __subscription="$2"
  local __ts=$(date +%Y-%m-%dT%H:%M:%SZ)

  # Specify subscription only if provided in the parameters. Otherwise az will use the current one.
  local subscription_args=()
  if [ -n "${__subscription:-}" ]; then
    subscription_args=(--subscription "$__subscription")
  fi

  # Read existing tags as JSON (null if none), then merge/overwrite the Created/CleanupFrequency/Owner keys.
  local existing_tags_json
  existing_tags_json=$(az group show "${subscription_args[@]}" --name "$__resource_group" --query tags -o json 2>/dev/null || echo null)

  local new_tags_json
  new_tags_json=$(echo "$existing_tags_json" | jq --arg ts "$__ts" '. // {} | .Created=$ts')

  # Convert merged tags JSON into key=value pairs for the --tags arg.
  local tags_kv
  IFS=$'\n' read -r -d '' -a tags_kv < <(echo "$new_tags_json" | jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' && printf '\0')

  az group update "${subscription_args[@]}" --name "$__resource_group" --tags "${tags_kv[@]}" --only-show-errors >/dev/null
}
