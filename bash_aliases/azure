# Azure subscriptions
alias .sandbox='az account set -s a3eeb848-665a-4dbf-80a4-eb460930fb23'
alias .dev='az account set -s fca2e8ee-1179-48b8-9532-428ed0873a2e'

# Login helper ensuring desired tenant + subscription selected
azure_login() {
  local target_tenant="72f988bf-86f1-41af-91ab-2d7cd011db47"
  local target_subscription="a3eeb848-665a-4dbf-80a4-eb460930fb23"
  local force="false"
  local verbose="false"

  # Flags: --force forces re-login; --verbose prints diagnostics
  while [ $# -gt 0 ]; do
    case "$1" in
      --force) force="true" ; shift ;;
      --verbose|-v) verbose="true" ; shift ;;
      *) break ;;
    esac
  done

  # Environment override: AZURE_LOGIN_FORCE=1 forces re-login
  if [ "${AZURE_LOGIN_FORCE:-}" = "1" ]; then
    force="true"
  fi

  # Helper to log when verbose
  _azl_log() { [ "$verbose" = "true" ] && echo "[azure_login] $*" || true; }

  # Determine current subscription (may be present even if token expired)
  local current_sub="" current_tenant=""
  if current_sub=$(az account show --query id -o tsv 2>/dev/null); then
    current_tenant=$(az account show --query tenantId -o tsv 2>/dev/null || true)
    _azl_log "Detected current subscription: $current_sub (tenant: $current_tenant)"
  fi

  # Function to test whether tokens are currently usable. We request an access token; this will fail fast if refresh token expired.
  _token_valid() {
    az account get-access-token --resource https://management.azure.com/ --query accessToken -o tsv >/dev/null 2>&1
  }

  # Fast path: subscription matches AND token retrieval works AND not forced.
  if [ "$force" = "false" ] && [ "$current_sub" = "$target_subscription" ]; then
    if _token_valid; then
      _azl_log "Fast path: valid token & correct subscription; no re-login needed.";
      return 0
    else
      _azl_log "Token invalid/expired; re-authentication required."
    fi
  fi

  # Prefer service principal creds if present (non-interactive)
  if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ]; then
    local login_tenant="${AZURE_TENANT_ID:-$target_tenant}"
    echo "Logging into Azure with service principal for tenant $login_tenant ..."
    if ! az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$login_tenant" --only-show-errors >/dev/null; then
      echo "Failed SP login" >&2
      return 1
    fi
  else
    echo "Interactive Azure login for tenant $target_tenant ..."
    if ! az login --tenant "$target_tenant" --only-show-errors >/dev/null; then
      echo "Interactive login failed" >&2
      return 1
    fi
  fi

  # Select subscription explicitly
  if ! az account set -s "$target_subscription" 2>/dev/null; then
    echo "Failed to set subscription $target_subscription" >&2
    return 1
  fi

  # Optional: reduce noisy warnings for subsequent commands
  az config set core.only_show_errors=true >/dev/null 2>&1 || true

  if _token_valid; then
    _azl_log "Verified new token acquisition succeeded."
  else
    _azl_log "Warning: token validation failed immediately after login (this is unexpected)."
  fi

  echo "Azure CLI context set to subscription: $target_subscription (tenant: $target_tenant)"
}

# Search for Azure Resource Groups by chaining contains filters.
getrg() {
  local query="[]"
  for arg in "$@"; do
    query="[?contains(name, '$arg')] | $query"
  done
  query="${query% | []}"
  az group list --query "$query.{Name:name, Location:location}" --output table
}

# Check for resource groups containing 'simdev' and the provided match pattern, and provide the user with an
# interactive menu to select the desired simulator and action (e.g. ssh, extension update, run tests).
# Interactive actions:
#   1) SSH into the simulator via sim_ssh
#   2) Run cluster-health API tests via sim_health
#   3) Update nc-platform-underlay-extension to a target version
#   4) List matching simulator resource groups + Janitor TTL (with optional weekly extend)
#
# Flags:
#   --help            display usage information
#
# When multiple matches exist, results are shown newest-first but the default selection targets the oldest build.
sim() {
  local action=""
  local resourceGroupFilter=""
  local usage_msg="Usage: sim [--help] [filter]\n\n  --help    display this message\n  filter    optional substring to narrow RG names\n\nYou will be prompted to choose an action before selecting a simulator:\n  1) SSH into the selected simulator\n  2) Run cluster-health API tests\n  3) Update nc-platform-underlay-extension\n  4) List matching simulator resource groups + Janitor TTL (with optional weekly extend)"

  # Parse input arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --help|-h)
        echo -e "$usage_msg"
        return 0
        ;;
      --*)
        echo "Unknown option: $1" >&2
        echo -e "$usage_msg" >&2
        return 1
        ;;
      *)
        if [ -n "$resourceGroupFilter" ]; then
          echo "Only one filter argument is supported" >&2
          echo -e "$usage_msg" >&2
          return 1
        fi
        resourceGroupFilter="$1"
        shift
        ;;
    esac
  done

  # Default to 'robstarling' if no optional filter string is provided
  if [ -z "$resourceGroupFilter" ]; then
    resourceGroupFilter="robstarling"
  fi

  # Retrieve list of sim resource groups containing 'simdev' and the supplied filter string
  local rg_list
  if ! rg_list=$(az group list --query "[?contains(name, '$resourceGroupFilter') && contains(name, 'simdev')].name" --output tsv 2>/dev/null); then
    echo "Failed to retrieve Azure resource groups" >&2
    return 1
  fi

  local filter_lower=${resourceGroupFilter,,}
  local candidates=()
  while IFS= read -r rg; do
    [ -z "$rg" ] && continue
    # [[ $rg != robstarling* ]] && continue
    [[ $rg =~ -simdev-[0-9]+$ ]] || continue
    if [ -n "$filter_lower" ]; then
      local rg_lower=${rg,,}
      [[ $rg_lower == *"$filter_lower"* ]] || continue
    fi
    candidates+=("$rg")
  done <<<"$rg_list"

  local count=${#candidates[@]}

  case "$count" in
    0)
      echo "No simulator resource groups found matching filter '$resourceGroupFilter'" >&2
      return 1
      ;;
    1)
      echo "${candidates[0]}:"
      ;;
    *)
      echo "${candidates[0]}... (and $((count - 1)) more for '$resourceGroupFilter'):"
      ;;
  esac

  local sorted_candidates=("${candidates[@]}")
  if [ "$count" -gt 1 ]; then
    local sorted_output
    sorted_output=$(printf '%s\n' "${sorted_candidates[@]}" | awk '{
        build=0
        if (match($0, /simdev-([0-9]+)/, m)) { build=m[1] }
        printf "%010d\t%s\n", build, $0
      }' | sort -k1,1nr | cut -f2-)
    mapfile -t sorted_candidates <<<"$sorted_output"
  fi

  # Ask user to select an action to perform
  while [ -z "$action" ]; do
    echo "  1) SSH into simulator"
    echo "  2) Run cluster-health API tests"
    echo "  3) List/update nc-platform-underlay-extension"
    echo "  4) List/extend Janitor TTL"
    echo "  0) Exit"
    local action_reply=""
    printf 'Choice [0]: '
    if ! read -r action_reply; then
      echo
      action="ssh"
      break
    fi
    case "$action_reply" in
      "1")
        action="ssh"
        ;;
      "2")
        action="health"
        ;;
      "3")
        action="update_extension"
        ;;
      "4")
        action="list"
        ;;
      "0"|""|*)
        return 0
        ;;
    esac
  done

  if [ "$action" = "list" ]; then
    echo
    echo "Listing $count simulator resource group(s) matching '$resourceGroupFilter':"
    local idx=1
    for rg in "${sorted_candidates[@]}"; do
      local janitor_output=""
      janitor_output=$(janitor "$rg" 2>&1 || true)
      local last_line
      last_line=$(echo "$janitor_output" | tail -n 1)
      if [ -n "$last_line" ]; then
        echo "  $idx) $rg: $last_line"
      else
        echo "  $idx) $rg: <no janitor output>"
      fi
      idx=$((idx + 1))
    done

    echo
    printf 'Enter #/name (blank to return) to extend TTL weekly: '
    local ttl_choice=""
    read -r ttl_choice
    ttl_choice=${ttl_choice//[[:space:]]/}
    if [ -z "$ttl_choice" ]; then
      return 0
    fi

    local ttl_target=""
    if [[ "$ttl_choice" =~ ^[0-9]+$ ]]; then
      local choice_num=$((10#$ttl_choice))
      if [ "$choice_num" -ge 1 ] && [ "$choice_num" -le "${#sorted_candidates[@]}" ]; then
        local choice_index=$((choice_num - 1))
        ttl_target="${sorted_candidates[$choice_index]}"
      else
        echo "Selection $ttl_choice out of range; no changes made."
        return 0
      fi
    else
      for rg in "${sorted_candidates[@]}"; do
        if [ "$rg" = "$ttl_choice" ]; then
          ttl_target="$rg"
          break
        fi
      done

      if [ -z "$ttl_target" ]; then
        echo "RG '$ttl_choice' not in filtered list; no changes made."
        return 0
      fi
    fi

    echo "Extending Janitor TTL (weekly) for $ttl_target ..."
    if janitor_reset -g "$ttl_target" -f weekly; then
      echo "Janitor TTL updated for $ttl_target"
    else
      echo "Failed to update Janitor TTL for $ttl_target" >&2
      return 1
    fi
    return 0
  fi

  local selected_rg=""

  if [ "$action" = "update_extension" ]; then
    echo
    echo "Current nc-platform-underlay-extension versions:"
    local idx=1
    for rg in "${sorted_candidates[@]}"; do
      local version_display="<unknown>"
      local build_id
      build_id=$(echo "$rg" | grep -oE '[0-9]+$' || true)
      if [ -n "$build_id" ]; then
        local hosted_rg=""
        local hosted_candidates
        if hosted_candidates=$(az group list --query "[?contains(name, 'simdev-${build_id}-cluster-1-HostedResources-')].name" --output tsv 2>/dev/null); then
          while IFS= read -r host_rg; do
            [ -z "$host_rg" ] && continue
            [[ $host_rg == simdev-${build_id}-cluster-1-HostedResources-* ]] || continue
            hosted_rg="$host_rg"
            break
          done <<<"$hosted_candidates"
        fi

        if [ -n "$hosted_rg" ]; then
          local cluster_name="${hosted_rg%-HostedResources-*}"
          local current_version
          if current_version=$(az k8s-extension show \
              --name nc-platform-underlay-extension \
              --resource-group "$hosted_rg" \
              --cluster-name "$cluster_name" \
              --cluster-type connectedClusters \
              --query version -o tsv 2>/dev/null); then
            if [ -n "$current_version" ]; then
              version_display="$current_version"
            else
              version_display="<empty response>"
            fi
          else
            version_display="<lookup failed>"
          fi
        else
          version_display="<missing HostedResources>"
        fi
      else
        version_display="<invalid build id>"
      fi

      echo "  $idx) $rg: $version_display"
      idx=$((idx + 1))
    done

    echo
    printf 'Enter #/name (blank to return) to update extension: '
    local ext_choice=""
    read -r ext_choice
    ext_choice=${ext_choice//[[:space:]]/}
    if [ -z "$ext_choice" ]; then
      return 0
    fi

    if [[ "$ext_choice" =~ ^[0-9]+$ ]]; then
      local choice_num=$((10#$ext_choice))
      if [ "$choice_num" -ge 1 ] && [ "$choice_num" -le "${#sorted_candidates[@]}" ]; then
        local choice_index=$((choice_num - 1))
        selected_rg="${sorted_candidates[$choice_index]}"
      else
        echo "Selection $ext_choice out of range; no changes made."
        return 0
      fi
    else
      for rg in "${sorted_candidates[@]}"; do
        if [ "$rg" = "$ext_choice" ]; then
          selected_rg="$rg"
          break
        fi
      done
      if [ -z "$selected_rg" ]; then
        echo "RG '$ext_choice' not in filtered list; no changes made."
        return 0
      fi
    fi
  fi

  if [ -z "$selected_rg" ]; then
    if [ "$count" -eq 1 ]; then
      selected_rg="${sorted_candidates[0]}"
    else
      local last_index=$(( ${#sorted_candidates[@]} - 1 ))
      local default_rg="${sorted_candidates[$last_index]}"
      local default_position=$((last_index + 1))
      local selection=""

      if command -v fzf >/dev/null 2>&1; then
        local fzf_opts=(
          --prompt "Select simulator RG > "
          --header "Enter accepts default (#${default_position})"
          --height=40%
          --reverse
        )
        selection=$(printf '%s\n' "${sorted_candidates[@]}" | fzf "${fzf_opts[@]}")
        if [ -z "$selection" ]; then
          echo "No selection made; defaulting to $default_rg"
          selection="$default_rg"
        fi
      else
        echo "Multiple simulator resource groups found (default: oldest):"
        local idx=1
        for rg in "${sorted_candidates[@]}"; do
          printf '  %d) %s\n' "$idx" "$rg"
          idx=$((idx + 1))
        done
        printf 'Select target (default %d): ' "$default_position"
        local reply
        read -r reply
        if [ -z "$reply" ]; then
          selection="$default_rg"
        elif [[ "$reply" =~ ^[0-9]+$ ]] && [ "$reply" -ge 1 ] && [ "$reply" -le "${#sorted_candidates[@]}" ]; then
          local reply_index=$((reply - 1))
          selection="${sorted_candidates[$reply_index]}"
        else
          echo "Invalid selection" >&2
          return 1
        fi
      fi

      selected_rg="$selection"
    fi
  fi

  local build_id
  build_id=$(echo "$selected_rg" | grep -oE '[0-9]+$')
  if [ -z "$build_id" ]; then
    echo "Unable to parse simdev build id from $selected_rg" >&2
    return 1
  fi

  case "$action" in
    ssh)
      sim_ssh "$build_id"
      ;;
    health)
      if ! type sim_health >/dev/null 2>&1; then
        echo "sim_health function is not available in this shell" >&2
        return 1
      fi
      sim_health "$build_id"
      ;;
    update_extension)
      echo "Looking up current nc-platform-underlay-extension version for simdev-${build_id}..."

      local hosted_rg=""
      local hosted_candidates
      if ! hosted_candidates=$(az group list --query "[?contains(name, 'simdev-${build_id}-cluster-1-HostedResources-')].name" --output tsv 2>/dev/null); then
        echo "Failed to retrieve HostedResources groups" >&2
        return 1
      fi
      while IFS= read -r rg; do
        [ -z "$rg" ] && continue
        [[ $rg == simdev-${build_id}-cluster-1-HostedResources-* ]] || continue
        hosted_rg="$rg"
        break
      done <<<"$hosted_candidates"

      if [ -z "$hosted_rg" ]; then
        echo "Unable to locate HostedResources group for build ${build_id}" >&2
        return 1
      fi

      local cluster_name="${hosted_rg%-HostedResources-*}"
      local current_version=""
      if current_version=$(az k8s-extension show \
          --name nc-platform-underlay-extension \
          --resource-group "$hosted_rg" \
          --cluster-name "$cluster_name" \
          --cluster-type connectedClusters \
          --query version -o tsv 2>/dev/null); then
        if [ -n "$current_version" ]; then
          echo "Current nc-platform-underlay-extension version: $current_version"
        else
          echo "Current nc-platform-underlay-extension version: <unknown> (empty response)"
        fi
      else
        echo "Warning: unable to determine current nc-platform-underlay-extension version" >&2
      fi

      local target_version=""
      while [ -z "$target_version" ]; do
        printf 'Enter target nc-platform-underlay-extension version: '
        if ! read -r target_version; then
          echo
          echo "Extension update aborted (no version provided)." >&2
          return 1
        fi
        target_version="${target_version//[[:space:]]/}"
        if [ -z "$target_version" ]; then
          echo "Version cannot be empty." >&2
        fi
      done

      local NC_PLATFORM_EXTENSION="$target_version"
      local command_preview="az k8s-extension update --name nc-platform-underlay-extension --resource-group ${hosted_rg} --cluster-name ${cluster_name} --cluster-type connectedClusters --version ${NC_PLATFORM_EXTENSION} --auto-upgrade false --release-train sandbox"

      echo
      echo "Run the following command? (Y/N)"
      echo "  $command_preview"
      printf 'Proceed? [Y]: '
      local confirm=""
      if ! read -r confirm; then
        echo
        confirm="y"
      fi
      [ -z "$confirm" ] && confirm="y"

      if [[ "$confirm" =~ ^[Yy]$ ]]; then
        if ! az k8s-extension update \
          --name nc-platform-underlay-extension \
          --resource-group "$hosted_rg" \
          --cluster-name "$cluster_name" \
          --cluster-type connectedClusters \
          --version "$NC_PLATFORM_EXTENSION" \
          --auto-upgrade false \
          --release-train sandbox; then
          echo "nc-platform-underlay-extension update failed." >&2
          return 1
        fi
      else
        echo "nc-platform-underlay-extension update skipped."
      fi
      ;;
    *)
      echo "Unhandled action: $action" >&2
      return 1
      ;;
  esac
}

# ssh to a simulator using only the build number, e.g.
#   sim_ssh 3391322
sim_ssh() {
  local build_id=$1
  local sandboxSubscription=a3eeb848-665a-4dbf-80a4-eb460930fb23

  if [[ -z "$build_id" || ! "$build_id" =~ ^[0-9]+$ ]]; then
    echo "Usage: sim_ssh <build-id>" >&2
    return 1
  fi

  local rg_candidates target_rg=""
  if ! rg_candidates=$(az group list --query "[?contains(name, 'simdev-${build_id}')].name" --output tsv 2>/dev/null); then
    echo "Failed to retrieve simulator resource groups" >&2
    return 1
  fi

  while IFS= read -r rg; do
    [ -z "$rg" ] && continue
    [[ $rg == *"id-simdev-${build_id}"* ]] || continue
    target_rg="$rg"
    break
  done <<<"$rg_candidates"

  if [ -z "$target_rg" ]; then
    echo "Unable to locate simulator resource group for build ${build_id}" >&2
    return 1
  fi

  az ssh arc -g "$target_rg" -n "simdev-${build_id}-vm-1" --subscription $sandboxSubscription
}

# Function to retrieve and assign BMM Replace values to environment variables
get_baremetal_info() {
  local RG=$1
  local MACHINE_NAME=$2

  # Retrieve the values and assign them to environment variables
  local machine_info=$(az networkcloud baremetalmachine show -n $MACHINE_NAME -g $RG --query "{machineName:machineName, bootMacAddress:bootMacAddress, bmcMacAddress:bmcMacAddress, serialNumber:serialNumber}" --output tsv)

  # Split the output into individual variables
  read machineName bootMacAddress bmcMacAddress serialNumber <<< "$machine_info"

  # Export the variables to make them available in the current shell session
  export machineName
  export bootMacAddress
  export bmcMacAddress
  export serialNumber

  # Print the values to verify
  echo "\$machineName: $machineName"
  echo "\$bootMacAddress: $bootMacAddress"
  echo "\$bmcMacAddress: $bmcMacAddress"
  echo "\$serialNumber: $serialNumber"

  # BMC password is also needed
  echo
  echo "To retrieve BMC password:"
  echo "kubectl -n nc-system get secret $machineName-bmc -o json | jq -r .data.password | base64 -d"
}

# janitor checks an Azure resource group's "Created" tag,
# which is used by the Janitor to determine when to clean up the resource group.
#
# Usage:
#   azure_rg_reset_created_tag RESOURCE_GROUP [SUBSCRIPTION]
janitor() {
  local __resource_group="$1"
  local __subscription="$2"

  # Specify subscription only if provided in the parameters. Otherwise az will use the current one.
  local subscription_args=()
  if [ -n "${__subscription:-}" ]; then
    subscription_args=(--subscription "$__subscription")
  fi

  # Read existing tags as JSON (null if none)
  local tags_json
  if ! tags_json=$(az group show "${subscription_args[@]}" --name "$__resource_group" --query tags -o json 2>/dev/null); then
    echo "Failed to retrieve tags for resource group: $__resource_group" >&2
    return 1
  fi

  echo "$tags_json"

  # Parse Created/CleanupFrequency tags to compute the TTL for days_until_stale
  local created="" cleanup_frequency="" ttl_days=1
  if command -v jq >/dev/null 2>&1; then
    created=$(echo "$tags_json" | jq -r '.Created // empty')
    cleanup_frequency=$(echo "$tags_json" | jq -r '.CleanupFrequency // empty')
  else
    created=$(echo "$tags_json" | grep -o '"Created"[^"]*"[^"]*"' | sed -E 's/.*"Created" *: *"([^"]*)".*/\1/')
    cleanup_frequency=$(echo "$tags_json" | grep -o '"CleanupFrequency"[^"]*"[^"]*"' | sed -E 's/.*"CleanupFrequency" *: *"([^"]*)".*/\1/' || true)
  fi

  if [ -z "$created" ]; then
    echo "> 1 day remaining (No valid 'Created' tag)"
    return 1
  fi

  case "${cleanup_frequency,,}" in
    daily)
      ttl_days=1
      ;;
    weekly)
      ttl_days=7
      ;;
    monthly)
      ttl_days=30
      ;;
    never|""|*)
      echo "> 1 day remaining (No valid 'CleanupFrequency' tag: '$cleanup_frequency')"
      return 3
      ;;
  esac

  local remaining
  remaining=$(days_until_stale "$created" "$ttl_days" 2>/dev/null || true)
  if [ -n "$remaining" ]; then
    echo "$remaining remaining"
  else
    echo "Error computing staleness for resource group: $__resource_group" >&2
    return 4
  fi
}

# azure_rg_reset_created_tag updates an Azure resource group's "Created" tag,
# optionally overriding CleanupFrequency, to influence the Janitor cleanup window.
#
# Usage:
#   janitor_reset                         # defaults to $devboxRG / $devboxSub
#   janitor_reset -g RG [-s SUB] [-f FREQ]
janitor_reset() {
  local __ts=$(date +%Y-%m-%dT%H:%M:%SZ)
  local __resource_group=""
  local __subscription=""
  local __frequency=""
  local __arg_count=$#

  while [ $# -gt 0 ]; do
    case "$1" in
      -h|--help)
        echo "Usage: janitor_reset [-g RESOURCE_GROUP] [-s SUBSCRIPTION] [-f FREQUENCY]"
        echo
        echo "  -g RESOURCE_GROUP   Name of the Azure resource group to update"
        echo "  -s SUBSCRIPTION     (Optional) Subscription ID containing the resource group"
        echo "  -f FREQUENCY        (Optional) Cleanup frequency: daily, weekly, monthly, never"
        return 0
        ;;
      -g)
        if [ -z "${2:-}" ]; then
          echo "janitor_reset: -g requires a resource group" >&2
          return 1
        fi
        __resource_group="$2"
        shift 2
        ;;
      -s)
        if [ -z "${2:-}" ]; then
          echo "janitor_reset: -s requires a subscription id" >&2
          return 1
        fi
        __subscription="$2"
        shift 2
        ;;
      -f)
        if [ -z "${2:-}" ]; then
          echo "janitor_reset: -f requires a frequency" >&2
          return 1
        fi
        __frequency="$2"
        shift 2
        ;;
      -* )
        echo "janitor_reset: unknown option '$1'" >&2
        return 1
        ;;
      *)
        echo "janitor_reset: unexpected argument '$1'" >&2
        return 1
        ;;
    esac
  done

  if [ "$__arg_count" -eq 0 ]; then
    if [ -z "${devboxRG:-}" ] || [ -z "${devboxSub:-}" ]; then
      echo "janitor_reset: resource group must be specified via -g or set \$devboxRG and \$devboxSub" >&2
      return 1
    fi
    __resource_group="$devboxRG"
    __subscription="$devboxSub"
  else
    if [ -z "$__resource_group" ]; then
      echo "janitor_reset: resource group must be specified via -g" >&2
      return 1
    fi
  fi

  local subscription_args=()
  if [ -n "${__subscription:-}" ]; then
    subscription_args=(--subscription "$__subscription")
  fi

  local existing_tags_json
  existing_tags_json=$(az group show "${subscription_args[@]}" --name "$__resource_group" --query tags -o json 2>/dev/null || echo null)

  local new_tags_json
  new_tags_json=$(echo "$existing_tags_json" | jq --arg ts "$__ts" '. // {} | .Created=$ts')

  if [ -n "$__frequency" ]; then
    local __frequency_normalized="${__frequency,,}"
    new_tags_json=$(echo "$new_tags_json" | jq --arg freq "$__frequency_normalized" '.CleanupFrequency=$freq')
  fi

  local tags_kv
  IFS=$'\n' read -r -d '' -a tags_kv < <(echo "$new_tags_json" | jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' && printf '\0')

  az group update "${subscription_args[@]}" --name "$__resource_group" --tags "${tags_kv[@]}" --only-show-errors >/dev/null

  # Call janitor to show updated TTL
  janitor "$__resource_group" "$__subscription"
}
