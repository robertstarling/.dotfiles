# Azure subscriptions
alias .sandbox='az account set -s a3eeb848-665a-4dbf-80a4-eb460930fb23'
alias .dev='az account set -s fca2e8ee-1179-48b8-9532-428ed0873a2e'

# Login helper ensuring desired tenant + subscription selected
azure_login() {
  local target_tenant="72f988bf-86f1-41af-91ab-2d7cd011db47"
  local target_subscription="a3eeb848-665a-4dbf-80a4-eb460930fb23"
  local force="false"
  local verbose="false"

  # Flags: --force forces re-login; --verbose prints diagnostics
  while [ $# -gt 0 ]; do
    case "$1" in
      --force) force="true" ; shift ;;
      --verbose|-v) verbose="true" ; shift ;;
      *) break ;;
    esac
  done

  # Environment override: AZURE_LOGIN_FORCE=1 forces re-login
  if [ "${AZURE_LOGIN_FORCE:-}" = "1" ]; then
    force="true"
  fi

  # Helper to log when verbose
  _azl_log() { [ "$verbose" = "true" ] && echo "[azure_login] $*" || true; }

  # Determine current subscription (may be present even if token expired)
  local current_sub="" current_tenant=""
  if current_sub=$(az account show --query id -o tsv 2>/dev/null); then
    current_tenant=$(az account show --query tenantId -o tsv 2>/dev/null || true)
    _azl_log "Detected current subscription: $current_sub (tenant: $current_tenant)"
  fi

  # Function to test whether tokens are currently usable. We request an access token; this will fail fast if refresh token expired.
  _token_valid() {
    az account get-access-token --resource https://management.azure.com/ --query accessToken -o tsv >/dev/null 2>&1
  }

  # Fast path: subscription matches AND token retrieval works AND not forced.
  if [ "$force" = "false" ] && [ "$current_sub" = "$target_subscription" ]; then
    if _token_valid; then
      _azl_log "Fast path: valid token & correct subscription; no re-login needed.";
      return 0
    else
      _azl_log "Token invalid/expired; re-authentication required.";
    fi
  fi

  # Prefer service principal creds if present (non-interactive)
  if [ -n "$AZURE_CLIENT_ID" ] && [ -n "$AZURE_CLIENT_SECRET" ]; then
    local login_tenant="${AZURE_TENANT_ID:-$target_tenant}"
    echo "Logging into Azure with service principal for tenant $login_tenant ..."
    if ! az login --service-principal -u "$AZURE_CLIENT_ID" -p "$AZURE_CLIENT_SECRET" --tenant "$login_tenant" --only-show-errors >/dev/null; then
      echo "Failed SP login" >&2
      return 1
    fi
  else
    echo "Interactive Azure login for tenant $target_tenant ..."
    if ! az login --tenant "$target_tenant" --only-show-errors >/dev/null; then
      echo "Interactive login failed" >&2
      return 1
    fi
  fi

  # Select subscription explicitly
  if ! az account set -s "$target_subscription" 2>/dev/null; then
    echo "Failed to set subscription $target_subscription" >&2
    return 1
  fi

  # Optional: reduce noisy warnings for subsequent commands
  az config set core.only_show_errors=true >/dev/null 2>&1 || true

  if _token_valid; then
    _azl_log "Verified new token acquisition succeeded."
  else
    _azl_log "Warning: token validation failed immediately after login (this is unexpected)."
  fi

  echo "Azure CLI context set to subscription: $target_subscription (tenant: $target_tenant)"
}

# Search for Azure Resource Groups
getrg() {
  local query="[]"
  for arg in "$@"; do
    query="[?contains(name, '$arg')] | $query"
  done
  query="${query% | []}"
  az group list --query "$query.{Name:name, Location:location}" --output table
}

# Search for Simulator hosted resource groups
function getsim() {
    local first_pattern="$1"
    local second_pattern_prefix="$2"

    # Get resource groups matching the first pattern
    local resource_groups=$(az group list --query "[?contains(name, 'robstarling') && contains(name, 'simdev')].name" --output tsv)
    echo $resource_groups

    for rg in $resource_groups; do
      # Extract the unique identifier from the first pattern
      local unique_id=$(echo $rg | grep -oP '(?<=simdev-)\d+')
      echo $unique_id

      # Construct the second pattern
      local second_pattern="simdev-${unique_id}-cluster-1-HostedResources-"
      echo $second_pattern

      # Get resource groups matching the second pattern
      az group list --query "[?contains(name, '$second_pattern')].{Name:name, Location:location}" --output table
    done
}

# Check for resource groups matching 'robstarling*<optionalpattern>*-simdev-[0-9]*' and provide the user with an
# interactive menu of matching resource group names, allowing them to select one to ssh into, using the sim_ssh function below.
# The user can optionally provide a pattern to filter the resource groups further.
# If there is only one choice, ssh into it directly.
# If multiple choices, choose the most recent as the default (based on the build number suffix after simdev-)
sim() {
  local optionalFilter=$1
  local rg_list

  if ! rg_list=$(az group list --query "[?contains(name, 'robstarling') && contains(name, 'simdev')].name" --output tsv 2>/dev/null); then
    echo "Failed to retrieve Azure resource groups" >&2
    return 1
  fi

  local filter_lower=${optionalFilter,,}
  local candidates=()
  while IFS= read -r rg; do
    [ -z "$rg" ] && continue
    [[ $rg != robstarling* ]] && continue
    [[ $rg =~ -simdev-[0-9]+$ ]] || continue
    if [ -n "$filter_lower" ]; then
      local rg_lower=${rg,,}
      [[ $rg_lower == *"$filter_lower"* ]] || continue
    fi
    candidates+=("$rg")
  done <<<"$rg_list"

  local count=${#candidates[@]}
  if [ "$count" -eq 0 ]; then
    if [ -n "$optionalFilter" ]; then
      echo "No simulator resource groups found matching filter '$optionalFilter'" >&2
    else
      echo "No simulator resource groups found" >&2
    fi
    return 1
  fi

  if [ "$count" -eq 1 ]; then
    sim_ssh "${candidates[0]}"
    return $?
  fi

  local sorted_output
  sorted_output=$(printf '%s\n' "${candidates[@]}" | awk '{
      build=0
      if (match($0, /simdev-([0-9]+)/, m)) { build=m[1] }
      printf "%010d\t%s\n", build, $0
    }' | sort -k1,1nr | cut -f2-)

  mapfile -t candidates <<<"$sorted_output"
  local last_index=$(( ${#candidates[@]} - 1 ))
  local default_rg="${candidates[$last_index]}"
  local default_position=$((last_index + 1))
  local selection=""

  if command -v fzf >/dev/null 2>&1; then
    local fzf_opts=(
      --prompt "Select simulator RG > "
      --header "Enter accepts default (#${default_position})"
      --height=40%
      --reverse
    )
    selection=$(printf '%s\n' "${candidates[@]}" | fzf "${fzf_opts[@]}")
    if [ -z "$selection" ]; then
      echo "No selection made; defaulting to $default_rg"
      selection="$default_rg"
    fi
  else
    echo "Multiple simulator resource groups found (default is most recent):"
    local idx=1
    for rg in "${candidates[@]}"; do
      printf '  %d) %s\n' "$idx" "$rg"
      idx=$((idx + 1))
    done
    printf 'Select target (default %d): ' "$default_position"
    local reply
    read -r reply
    if [ -z "$reply" ]; then
      selection="$default_rg"
    elif [[ "$reply" =~ ^[0-9]+$ ]] && [ "$reply" -ge 1 ] && [ "$reply" -le "${#candidates[@]}" ]; then
      local reply_index=$((reply - 1))
      selection="${candidates[$reply_index]}"
    else
      echo "Invalid selection" >&2
      return 1
    fi
  fi

  sim_ssh "$selection"
}

# ssh to simulator using the Resource Group name, e.g. 
#   getrg sim robstarling
#   sim robstarling-2504-12_id-simdev-3391322
sim_ssh() {
  local rg=$1
  local id=$(echo "$rg" | grep -oE '[0-9]+$')
  local sandboxSubscription=a3eeb848-665a-4dbf-80a4-eb460930fb23
  az ssh arc -g "$rg" -n "simdev-${id}-vm-1" --subscription $sandboxSubscription
}

# Function to retrieve and assign BMM Replace values to environment variables
get_baremetal_info() {
  local RG=$1
  local MACHINE_NAME=$2

  # Retrieve the values and assign them to environment variables
  local machine_info=$(az networkcloud baremetalmachine show -n $MACHINE_NAME -g $RG --query "{machineName:machineName, bootMacAddress:bootMacAddress, bmcMacAddress:bmcMacAddress, serialNumber:serialNumber}" --output tsv)

  # Split the output into individual variables
  read machineName bootMacAddress bmcMacAddress serialNumber <<< "$machine_info"

  # Export the variables to make them available in the current shell session
  export machineName
  export bootMacAddress
  export bmcMacAddress
  export serialNumber

  # Print the values to verify
  echo "\$machineName: $machineName"
  echo "\$bootMacAddress: $bootMacAddress"
  echo "\$bmcMacAddress: $bmcMacAddress"
  echo "\$serialNumber: $serialNumber"

  # BMC password is also needed
  echo
  echo "To retrieve BMC password:"
  echo "kubectl -n nc-system get secret $machineName-bmc -o json | jq -r .data.password | base64 -d"
}

# janitor checks an Azure resource group's "Created" tag,
# which is used by the Janitor to determine when to clean up the resource group.
#
# Usage:
#   azure_rg_reset_created_tag RESOURCE_GROUP [SUBSCRIPTION]
janitor() {
  local __resource_group="$1"
  local __subscription="$2"

  # Specify subscription only if provided in the parameters. Otherwise az will use the current one.
  local subscription_args=()
  if [ -n "${__subscription:-}" ]; then
    subscription_args=(--subscription "$__subscription")
  fi

  # Read existing tags as JSON (null if none)
  local tags_json
  if ! tags_json=$(az group show "${subscription_args[@]}" --name "$__resource_group" --query tags -o json 2>/dev/null); then
    echo "Failed to retrieve tags for resource group: $__resource_group" >&2
    return 1
  fi

  echo "$tags_json"

  # Parse the Created tag if present, and display the number of days remaining until stale
  local created=""
  if command -v jq >/dev/null 2>&1; then
    created=$(echo "$tags_json" | jq -r '.Created // empty')
  else
    created=$(echo "$tags_json" | grep -o '"Created"[^"]*"[^"]*"' | sed -E 's/.*"Created" *: *"([^"]*)".*/\1/')
  fi

  if [ -n "$created" ]; then
    if command -v days_until_stale >/dev/null 2>&1; then
      local remaining
      remaining=$(days_until_stale "$created" 30 2>/dev/null || true)
      [ -n "$remaining" ] && echo "$remaining remaining"
    else
      echo "Created: $created"
    fi
  fi  
}

# azure_rg_reset_created_tag updates an Azure resource group's "Created" tag,
# which is used by the Janitor to determine when to clean up the resource group.
#
# Usage:
#   azure_rg_reset_created_tag RESOURCE_GROUP SUBSCRIPTION
janitor_reset() {
  local __resource_group="$1"
  local __subscription="$2"
  local __ts=$(date +%Y-%m-%dT%H:%M:%SZ)

  # Specify subscription only if provided in the parameters. Otherwise az will use the current one.
  local subscription_args=()
  if [ -n "${__subscription:-}" ]; then
    subscription_args=(--subscription "$__subscription")
  fi

  # Read existing tags as JSON (null if none), then merge/overwrite the Created/CleanupFrequency/Owner keys.
  local existing_tags_json
  existing_tags_json=$(az group show "${subscription_args[@]}" --name "$__resource_group" --query tags -o json 2>/dev/null || echo null)

  local new_tags_json
  new_tags_json=$(echo "$existing_tags_json" | jq --arg ts "$__ts" '. // {} | .Created=$ts')

  # Convert merged tags JSON into key=value pairs for the --tags arg.
  local tags_kv
  IFS=$'\n' read -r -d '' -a tags_kv < <(echo "$new_tags_json" | jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' && printf '\0')

  az group update "${subscription_args[@]}" --name "$__resource_group" --tags "${tags_kv[@]}" --only-show-errors >/dev/null
}
